## 一、高斯消元
**高斯消元法** 求线性方程组的解，本质是将系数矩阵和常数项矩阵构造 **增广矩阵** ，利用初等行变换化简成 **最简形矩阵** ，可以说算法竞赛用到 **线性代数** 知识的只有高斯消元。以下给出具体实现：
```c++
const double eps=1e-9;
const int maxn=1005;
double a[maxn][maxn]={{6,2,1},{2,1,1},{-2,2,1}},x[maxn]={-1,1,7};   //a为系数矩阵,x为常数项矩阵
int equ=3,var=3;    //方程数和未知数个数
bool Gauss() {  //高斯消元法求解，若无解返回false

    int k,col,max_r;
    for(k=0,col=0;k<equ&&col<var;k++,col++){
        max_r=k;
        for(int i=k+1;i<equ;i++)
            if(fabs(a[i][col])>fabs(a[max_r][col])) max_r=i;    //找出这一列最大数（为了减小误差）
        if(fabs(a[max_r][col])<eps) return false;

        if(k!=max_r){   //将有最大数的那行与最上行交换
            for(int j=col;j<var;j++) swap(a[k][j],a[max_r][j]);
            swap(x[k],x[max_r]);
        }
        
        x[k]/=a[k][col];    //该行同除使第一个数为1
        for(int j=col+1;j<var;j++) a[k][j]/=a[k][col];
        a[k][col]=1;

        for(int i=0;i<equ;i++)  //该列同减使其他数都为0
            if(i!=k){
                x[i]-=x[k]*a[i][k];
                for(int j=col+1;j<var;j++) a[i][j]-=a[k][j]*a[i][col];
                a[i][col]=0;
            }
    }
    return true;
}
```
## 二、开关问题
对于存在自由变元的高斯消元问题，可以换个思路，作为开关问题来求解（如：` POJ 3279，POJ 1681`），利用 **状态压缩** + **暴力枚举** ，其复杂度比 **高斯消元** 小很多。
<a href="http://poj.org/problem?id=3279">来源：poj #3279</a><br>
题目大意：给定标记颜色的矩阵，可选定某些格子翻转，其本身及上下左右共5个各自都将变色，目的是让所有格子都为白色，求使得翻转数最小的操作。
1. 易知同一格子翻转偶数次会恢复原状，所以对于每个格子，翻转数只能是0或1。且翻转的次序与最终形态无关，所以可以按次序暴力。
2. 尝试从上往下，从左往右暴力。由于翻转范围为连通的“十”字型，所以务必枚举出第一行的所有翻转方法 ***(共2^n种方法，显然用二进制法)*** ，然后从第二行开始，判定(x,y)是否需要翻转，只需检查(x-1,y)是否为白色，因为此时(x-1,y)只能被(x,y)翻转。
3. 待暴力结束后，还需判别最后一行是否全为白。因为此时除最后一行其他所有格子皆为白色，最后一行一旦继续翻转，必然导致倒数第二行变为黑色，所以最后一行不能翻转。一旦有黑色格子，则此样例无解。
```c++
#include <iostream>
#include <climits>
#include <cstring>
#include <cstdio>
using namespace std;
const int maxn=20;
const int dx[]={0,-1,0,0,1};
const int dy[]={-1,0,0,1,0};
int m,n,a[maxn][maxn];
bool tmp[maxn][maxn];   //tmp即时保存最优解
bool b[maxn][maxn];     //b标记颜色

bool check(int x,int y){  //判定(x,y)是否需要翻转

    int c=a[x][y];
    for(int i=0;i<5;i++){
        int tx=x+dx[i],ty=y+dy[i];
        if(tx>=0&&ty>=0&&tx<m&&ty<n) c+=b[tx][ty];
    }
    return c&1;
}
int calc(){             //已知第1行，求最小操作数

    for(int i=1;i<m;i++)
        for(int j=0;j<n;j++)
            if(check(i-1,j)) b[i][j]=true;

    for(int j=0;j<n;j++)    //如果最后一行不全为白，则无解
        if(check(m-1,j)) return -1;

    int ct=0;
    for(int i=0;i<m;i++)
        for(int j=0;j<n;j++)
            ct+=b[i][j];

    return ct;
}
int main() {

    cin>>m>>n;
    for(int i=0;i<m;i++)
        for(int j=0;j<n;j++)
            cin>>a[i][j];

    int res=INT_MAX;
    for(int i=0;i<(1<<n);i++){
        memset(b,0,sizeof(b));
        for(int j=0;j<n;j++)
            b[0][j]=(i>>j)&1;   //二进制法枚举第1行的所有情况

        int t=calc();
        if(t!=-1&&res>t){
            res=t;
            memcpy(tmp,b,sizeof(b));
        }
    }

    if(res==INT_MAX) cout<<"IMPOSSIBLE"<<endl;
    else{
        for(int i=0;i<m;i++)
            for(int j=0;j<n;j++)
                printf("%d%c",tmp[i][j],j==n-1?'\n':' ');
    }

    return 0;
}
```

