## 一、模运算
模运算与基本四则运算相似，加和乘具有普适性，满足结合律、交换律、分配律。
```
   四则运算：
    (a + b) % p = (a % p + b % p) % p
    (a - b) % p = (a % p - b % p) % p
    (a * b) % p = (a % p * b % p) % p
     a ^ b % p = ((a % p)^b) % p
   结合律：
    ((a+b) % p + c) % p = (a + (b+c) % p) % p
    ((a*b) % p * c)% p = (a * (b*c) % p) % p
   交换律：
    (a + b) % p = (b+a) % p
    (a * b) % p = (b * a) % p
   分配律：
    (a+b) % p = ( a % p + b % p ) % p
    ((a +b)% p * c) % p = ((a * c) % p + (b * c) % p) % p
```
重要定理：
1.  若a≡b (% p)，则对于任意的c，都有`(a + c) ≡ (b + c) (%p)`；
2. 若a≡b (% p)，则对于任意的c，都有 `(a * c) ≡ (b * c) (%p)`；
3. 若a≡b (% p)，c≡d (% p)，则` (a + c) ≡ (b + d) (%p)，(a - c) ≡ (b - d) (%p)`，
4. `(a * c) ≡ (b * d) (%p)，(a / c) ≡ (b / d) (%p)`；
## 二、快速幂
利用二分的思想，把x^n转化成x^1,x^2,x^4,x^8...的乘积。算法复杂度为O(logn)。
```c++
typedef long long LL;
LL mod_pow(LL x,LL n,LL mod){//递推实现
    
    LL res=1;
    while(n>0){
        if(n&1) res=res*x%mod;
        x=x*x%mod;
        n>>=1;
    }
    return res;
}
LL mod_pow1(LL x,LL n,LL mod){//递归实现
    
    if(n==0) return 1;
    LL res=mod_pow1(x*x%mod,n/2,mod);
    if(n&1) res=res*x%mod;
    return res;
}
```
## 三、积性函数
**积性函数：** 对于任意互质的整数a,b，使得方程`f(ab)=f(a)f(b)`恒成立的数论函数。
**完全积性函数：** 对于任意整数a,b，满足上式的数论函数。
**举例：**
1. φ(n)，欧拉函数，小于n的正整数中与n互质的数的个数。
2. gcd(n,k)，最大公因数，当k固定时。
3. d(n)，n的正因子的数目。
4. σ(n)，n的正因子之和。
解 **余数之和** 或 **积性函数** 题时的一个技巧：
* 给定正整数i和n满足 i<=n，使得n/i=n/x成立的最大x为`n/(n/i)`，此处除法为向下取整。
## 三、离散对数问题
离散对数具有和一般对数相似的性质，当整数C有原根时，设A为C的一个原根，x,B为整数，则当`B ≡ A^x ( mod C)`时，余数方程`log_A (B) ≡ x ( mod φ(C))`恒成立。
离散对数问题可以简单描述为：给定一个质数C，和有限域ZC上的一个本原元A，对ZC上整数B，寻找唯一的整数x，使得满足上式。一般而言，如果仔细选择C，则该问题是难解的。
## 四、大步小步算法（BSGS）
**Baby Step Giant Step Algorithm，又称大步小步算法（某大佬称拔山盖世算法）。**
给定方程`A^x ≡ B (mod C)`，若C为质数或`gcd(A,C)=1`，求该方程的最小正整数解。
1. 若A≥ C,B≥C，可以先进行取模A%=C,B%=C，只考虑0≤A,B≤C。
2. 离散对数的满足`log_A (B) ≡ x ( mod φ(C))`，根据欧拉定理，原方程如果有解，则必然有一个 x∈[ 0,φ(C) )，所以直接枚举0~C-1，若能找到即为解，否则无解。复杂度为O(C)，能解决C较小的离散对数问题。
3. C较大时，进行优化。设`m = ceil( sqrt(C) ), x = i*m-j`，则`A^x = A^(mi) / A^j`，又`A^x ≡ B (mod C)`，所以` B(A^j) = A^(mi) `，1≤i≤m，0≤j≤m。
4. 先枚举j，把所有B*(A^j)加入hash表。然后枚举i，在hash表中查找A^(mi)，若能找到，则为所求解，否则无解。算法复杂度为 O( sqrt(C) logC )。

## 五、拓展大步小步（EXTBSGS）
由于原始的BSGS算法有局限性，当C不为质数时无法求解，而拓展BSGS可以解决C为和数的离散对数问题。
1. 对于方程`A^x ≡ B (mod C)`，可以设两个未知整数变量a,b，使得`aA^x+bC=B`。由 **贝祖定理** 可知，当且仅当`gcd(A,C) | B`时，方程有解，否则无解。
2. 对A^x',B,C不断消去公因子`d=gcd(A,C)`，设约分的次数为g，每次从A^x中取出一个A进行约分，约分后利用上述 **积性函数** 的性质，得出推导式：`A^x'' = (A^x') / A * (A/d)`。
3. 一直约分到`gcd(A^x'', C) = 1`为止，过程中如果`B mod gcd(A^x', C) ≠ 0`，则该方程无解。最终得到方程`k * A^(x-g) = B' (mod C)`，其中k为A/d的积。
4. 此时`gcd( k * A^(x-g) , C') = 1 `成立，从而可以利用GSBS算法求解。

## 六、模板题（离散对数）
<a href="http://www.spoj.com/problems/MOD/en/">来源：spoj MOD</a><br/>
题目大意：给定3个正整数x、y和z，可以通过快速幂模算法容易地找到k＝(x^y)%z。现在你的目标是求该算法的逆。给定3个正整数x、z和k，找到最小的非负整数y，使得k%z=(x^y)%z。
```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

LL mod_pow(LL x,LL n,LL mod){//快速幂

    LL res=1;
    while(n){
        if(n&1) res=res*x%mod;
        x=x*x%mod;
        n>>=1;
    }
    return res;
}
LL extbsgs(LL A,LL B,LL C){//A=B^x (mod C)

    A%=C;
    B%=C;
    if(A==1) return 0;
    LL ct=0,tmp=1;
    for(LL g =__gcd(B,C);g!=1;g=__gcd(B,C)){
        if(A%g) return -1;
        ct++;
        A/=g;
        C/=g;
        tmp=tmp*B/g%C;
        if(A==tmp) return ct;
    }
    //此时gcd(B,C')==1

    //大步小步A'=B^(im-j+ct),tmp=B^ct (mod C')
    LL m=(LL)(sqrt(C)+1),tt=C;
    map<LL,LL> hash;
    for(int j=0;j<=m;j++){
        hash[tt]=j;
        tt=tt*B%C;//当C为LL时注意溢出
    }
    B=mod_pow(B,m,C);
    for(int i=1;i<=m;i++){//A'*B^j = B^(im)* B^ct ,枚举i
        tmp=tmp*B%C;
        if(hash.count(tmp)) return i*m-hash[tmp]+ct;
    }
    return -1;
}
int main(){

    LL x,y,z,k;
    while(cin>>x>>z>>k){
        y=extbsgs(k,x,z);//k=x^y (mod z)
        if(y==-1) cout<<"No Solution"<<endl;
        else cout<<y<<endl;
    }
    return 0;
}
```
