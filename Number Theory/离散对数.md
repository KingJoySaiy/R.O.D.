## 一、模运算
模运算与基本四则运算相似，加和乘具有普适性，满足结合律、交换律、分配律。
```
   四则运算：
    (a + b) % p = (a % p + b % p) % p
    (a - b) % p = (a % p - b % p) % p
    (a * b) % p = (a % p * b % p) % p
     a ^ b % p = ((a % p)^b) % p
   结合律：
    ((a+b) % p + c) % p = (a + (b+c) % p) % p
    ((a*b) % p * c)% p = (a * (b*c) % p) % p
   交换律：
    (a + b) % p = (b+a) % p
    (a * b) % p = (b * a) % p
   分配律：
    (a+b) % p = ( a % p + b % p ) % p
    ((a +b)% p * c) % p = ((a * c) % p + (b * c) % p) % p
```
重要定理：
1.  若a≡b (% p)，则对于任意的c，都有`(a + c) ≡ (b + c) (%p)`；
2. 若a≡b (% p)，则对于任意的c，都有 `(a * c) ≡ (b * c) (%p)`；
3. 若a≡b (% p)，c≡d (% p)，则` (a + c) ≡ (b + d) (%p)，(a - c) ≡ (b - d) (%p)`，
4. `(a * c) ≡ (b * d) (%p)，(a / c) ≡ (b / d) (%p)`；
## 二、快速幂
利用二分的思想，把x^n转化成x^1,x^2,x^4,x^8...的乘积。算法复杂度为O(logn)。
```c++
typedef long long LL;
LL mod_pow(LL x, LL n, LL mod){       //递推实现

    LL res = 1;
    while(n){
        if(n & 1) res = res * x % mod;
        x = x * x % mod;
        n >>= 1;
    }
    return res;
}
LL mod_pow1(LL x, LL n, LL mod){      //递归实现

    if(!n) return 1;
    LL res = mod_pow1(x * x % mod, n >> 1, mod);
    if(n & 1) res = res * x % mod;
    return res;
}
```
## 三、积性函数
**积性函数：** 对于任意互质的整数a,b，使得方程`f(ab)=f(a)f(b)`恒成立的数论函数。
**完全积性函数：** 对于任意整数a,b，满足上式的数论函数。
**举例：**
1. φ(n)，欧拉函数，小于n的正整数中与n互质的数的个数。
2. gcd(n,k)，最大公因数，当k固定时。
3. d(n)，n的正因子的数目。
4. σ(n)，n的正因子之和。
解 **余数之和** 或 **积性函数** 题时的一个技巧：
* 给定正整数i和n满足 i<=n，使得n/i=n/x成立的最大x为`n/(n/i)`，此处除法为向下取整。

## 三、离散对数问题
离散对数具有和一般对数相似的性质，当整数C有原根时，设A为C的一个原根，x,B为整数，则当`B ≡ A^x ( mod C)`时，余数方程`log_A (B) ≡ x ( mod φ(C))`恒成立。
离散对数问题可以简单描述为：给定一个质数C，和有限域ZC上的一个本原元A，对ZC上整数B，寻找唯一的整数x，使得满足上式。一般而言，如果仔细选择C，则该问题是难解的。

## 四、大步小步算法（BSGS）
**Baby Step Giant Step Algorithm，又称大步小步算法（某大佬称拔山盖世算法）。**
给定方程`A^x ≡ B (mod C)`，若C为质数或`gcd(A,C)=1`，求该方程的最小正整数解。
1. 若A≥ C,B≥C，可以先进行取模A%=C,B%=C，只考虑0≤A,B≤C。
2. 离散对数的满足`log_A (B) ≡ x ( mod φ(C))`，根据欧拉定理，原方程如果有解，则必然有一个 x∈[ 0,φ(C) )，所以直接枚举0~C-1，若能找到即为解，否则无解。复杂度为O(C)，能解决C较小的离散对数问题。
3. C较大时，进行优化。设`m = ceil( sqrt(C) ), x = i*m-j`，则`A^x = A^(mi) / A^j`，又`A^x ≡ B (mod C)`，所以` B(A^j) = A^(mi) `，1≤i≤m，0≤j≤m。
4. 先枚举j，把所有B*(A^j)加入hash表。然后枚举i，在hash表中查找A^(mi)，若能找到，则为所求解，否则无解。算法复杂度为 O( sqrt(C) logC )。

## 五、拓展大步小步（EXTBSGS）
由于原始的BSGS算法有局限性，当C不为质数时无法求解，而拓展BSGS可以解决C为和数的离散对数问题。
1. 对于方程`A^x ≡ B (mod C)`，可以设两个未知整数变量a,b，使得`aA^x+bC=B`。由 **贝祖定理** 可知，当且仅当`gcd(A,C) | B`时，方程有解，否则无解。
2. 对A^x',B,C不断消去公因子`d=gcd(A,C)`，设约分的次数为g，每次从A^x中取出一个A进行约分，约分后利用上述 **积性函数** 的性质，得出推导式：`A^x'' = (A^x') / A * (A/d)`。
3. 一直约分到`gcd(A^x'', C) = 1`为止，过程中如果`B mod gcd(A^x', C) ≠ 0`，则该方程无解。最终得到方程`k * A^(x-g) = B' (mod C)`，其中k为A/d的积。
4. 此时`gcd( k * A^(x-g) , C') = 1 `成立，从而可以利用GSBS算法求解。

## 六、模板题（离散对数）
[来源：UVALive 7457](https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=5479)
题目大意：对于公式`a ^ x = b (mod p)`，给定a,b,p求满足该式的最小非负整数x。
```c++
#include <bits/stdc++.h>

using namespace std;

typedef long long LL;

inline LL mod_pow(LL x, LL n, LL mod){

    LL res = 1;
    while(n){
        if(n & 1) res = res * x % mod;
        x = x * x % mod;
        n >>= 1;
    }
    return res;
}
LL extbsgs(LL a, LL y, LL p){   //y = a ^ x (mod p)

    a %= p;
    y %= p;
    if(!a) return y > 1 ? -1 : (y == 0 and p > 1);
    LL g, c = 0, q = 1;
    while ((g = __gcd(a, p)) != 1){
        if(y == 1) return c;
        if(y % g) return -1;
        ++c;
        y /= g;
        p /= g;
        q = a / g * q % p;
    }
    map<LL, LL> x;
    LL m = (LL)sqrt(p);
    for (LL i = 1, t = y * a % p; i <= m; ++i, t = t * a % p) x[t] = i;
    for (LL i = m, t = mod_pow(a, m, p); i - m < p-1; i += m)
        if (q = q * t % p, x.count(q)) return i - x[q] + c;
    return -1;
}
int main(){

    LL p, a, b, x;
    cin>>p;
    while(scanf("%lld", &a) != -1 and a){
        scanf("%lld", &b);
        x = extbsgs(a, b, p);
        cout<<(x == -1 ? 0 : x)<<endl;
    }

//    system("pause");
    return 0;
}
/*
31
24 3
3 15
0
 */
```
