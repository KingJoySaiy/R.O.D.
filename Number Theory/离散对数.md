## 一、模运算
模运算与基本四则运算相似，加和乘具有普适性，满足结合律、交换律、分配律。
```
   四则运算：
    (a + b) % p = (a % p + b % p) % p
    (a - b) % p = (a % p - b % p) % p
    (a * b) % p = (a % p * b % p) % p
     a ^ b % p = ((a % p)^b) % p
   结合律：
    ((a+b) % p + c) % p = (a + (b+c) % p) % p
    ((a*b) % p * c)% p = (a * (b*c) % p) % p
   交换律：
    (a + b) % p = (b+a) % p
    (a * b) % p = (b * a) % p
   分配律：
    (a+b) % p = ( a % p + b % p ) % p
    ((a +b)% p * c) % p = ((a * c) % p + (b * c) % p) % p
```
## 二、快速幂
利用二分的思想，把x^n转化成x^1,x^2,x^4,x^8...的乘积。算法复杂度为O(logn)。
```c++
typedef long long LL;
LL mod_pow(LL x,LL n,LL mod){//递推实现
    
    LL res=1;
    while(n>0){
        if(n&1) res=res*x%mod;
        x=x*x%mod;
        n>>=1;
    }
    return res;
}
LL mod_pow1(LL x,LL n,LL mod){//递归实现
    
    if(n==0) return 1;
    LL res=mod_pow1(x*x%mod,n/2,mod);
    if(n&1) res=res*x%mod;
    return res;
}
```


## 三、离散对数问题
离散对数具有和一般对数相似的性质，当整数C有原根时，设A为C的一个原根，x,B为整数，则当`B ≡ A^x ( mod C)`时，余数方程`log_A (B) ≡ x ( mod φ(C))`恒成立。
离散对数问题可以简单描述为：给定一个质数C，和有限域ZC上的一个本原元A，对ZC上整数B，寻找唯一的整数x，使得满足上式。一般而言，如果仔细选择C，则该问题是难解的。
## 四、大步小步算法（BSGS algorithm）
**Baby Step Giant Step Algorithm，又称大步小步算法（某大佬称拔山盖世算法）。**
给定方程`A^x ≡ B (mod C)`，若C为质数或`gcd(A,C)=1`，求该方程的最小正整数解。
1. 若A≥ C,B≥C，可以先进行取模A%=C,B%=C，只考虑0≤A,B≤C。
2. 离散对数的满足`log_A (B) ≡ x ( mod φ(C))`，根据欧拉定理，原方程如果有解，则必然有一个 x∈[ 0,φ(C) )，所以直接枚举0~C-1，若能找到即为解，否则无解。复杂度为O(C)，能解决C较小的离散对数问题。
3. C较大时，进行优化。设`m = ceil( sqrt(C) ), x = i*m-j`，则`A^x = A^(mi) / A^j`，又`A^x ≡ B (mod C)`，所以` B(A^j) = A^(mi) `，1≤i≤m，0≤j≤m。
4. 先枚举j，把所有B*(A^j)加入hash表。然后枚举i，在hash表中查找A^(mi)，若能找到，则为所求解，否则无解。算法复杂度为 O( sqrt(C) )。

## 五、拓展BSGS
由于原始的BSGS算法有局限性，当C不为质数时无法求解，而拓展BSGS可以解决C为和数的离散对数问题。

## 六、模板题（离散对数）
<a href="http://www.spoj.com/problems/MOD/en/">来源：spoj MOD</a>
题目大意：给定3个正整数x、y和z，可以通过快速幂模算法容易地找到k＝(x^y)%z。现在你的目标是求该算法的逆。给定3个正整数x、z和k，找到最小的非负整数y，使得k%z=(x^y)%z。
```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

LL power_mod(LL x,LL n, int mod){
    LL res =1;
    while (n) {
        if(n&1)res = res*x % mod;
        x = x*x %mod;
        n >>=1;
    }
    return res;
}

LL bsgs(LL A,LL C,LL mod){

    A %= mod;
    C %= mod;
    if(C==1)return 0;
    LL cnt =0;
    LL tmp = 1;
    for(LL g = __gcd(A,mod) ; g != 1 ; g = __gcd(A,mod)){
        if(C % g)return -1;//不能整除
        C /=g ; mod/=g ; tmp = tmp*A/g%mod;
        ++cnt;
        if(C == tmp)return cnt;
    }
    //大步小步a^xa^cnt=C (mod m)a^cnt = tmp;
    LL T = (LL)sqrt(0.5+mod);
    LL b = C;
    map<LL,LL> hash;
    hash[b] = 0;
    for(int i=1 ; i<=T ; ++i){
        b = b*A%mod;//当mod为LL时注意溢出
        hash[b] = i;
    }
    A = power_mod(A,T,mod);
    for(int u =1 ; u<=T ; ++u){
        tmp = tmp*A %mod;
        if(hash.count(tmp))return u*T-hash[tmp]+cnt;
    }
    return -1;
}

int main() {

    LL x,y,z,k;
    while (scanf("%lld%lld%lld",&x,&z,&k ) && z) {
        y = bsgs(x,k,z);
        if(y==-1) cout << "No Solution" << endl;
        else cout << y << endl;
    }
    return 0;
}
```
