## 一、单位复数根
* 定义：n次单位复数根是满足`w^n = 1`的复数w，n次单位复数根恰好有n个。对于`k = 0,1,2...n-1`，这些根是`e^(2πk/n i)`，值`w(n) = e^(2π/n i)`称为主n次单位根，所有其他n次单位复数根都是w(n)的幂次。复数的指数形式定义为`e^(u i) = cos(u) + i sin(u)`。
例如3次单位复数根如下：
[<img src="_image/fft_1.png" width="150" height="100" />]
* 基本性质

## 二、霍纳法则
给定`f(x) = a0 + a1x + a2x^2 + a3x^3... + anx^n`，对于 **多项式求值问题** ，常规思路是每一项求值然后累加，但时空复杂度较高。而 **霍纳法则** 可以在`O(n)`时间复杂度内完成求值运算。
公式为：`f(x) = a0 + x ( a1 + x ( a2+...+x( an-1+x(an) ) ) )`。模版如下：
```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=100;
double a[maxn];
int n;
double Horner(double x){    //f(x)=a0+a1x+a2x^2+a3x^3...+anx^n

    double res=0;
    for(int i=n;i>=0;i--) res=x*res+a[i];
    return res;
}
int main() {

    double x0;
    cin>>n;
    for(int i=0;i<=n;i++) cin>>a[i];
    cin>>x0;

    for(int i=n;i>=0;i--){
        if(i!=n) cout<<" + ";
        cout<<a[i]<<"*x^"<<i;
    }
    cout<<" = "<<Horner(x0)<<endl;

    return 0;
}

```
## 二、离散傅立叶（DFT）

## 三、快速傅立叶（FFT）

## 四、模版题（FFT）
<a href ="http://acm.hdu.edu.cn/showproblem.php?pid=1402">来源：hdu #1402</a><br>
题目大意：
```c++
#include <bits/stdc++.h>
using namespace std;
const double PI = acos(-1.0);
const int MAXN = 200010;

char str1[MAXN/2],str2[MAXN/2];
int sum[MAXN];

class Complex {//复数结构体
public:
    double x,y;//实部和虚部 x+yi
    Complex(double _x = 0.0,double _y = 0.0):x(_x),y(_y) {}
    Complex operator -(const Complex &b)const {
        return Complex(x-b.x,y-b.y);
    }
    Complex operator +(const Complex &b)const {
        return Complex(x+b.x,y+b.y);
    }
    Complex operator *(const Complex &b)const {
        return Complex(x*b.x-y*b.y,x*b.y+y*b.x);
    }
}x1[MAXN],x2[MAXN];
//进行FFT和IFFT前的反转变换。
//位置i和 （i二进制反转后位置）互换
//len必须去2的幂
void change(Complex y[],int len) {

    for(int i = 1, j = len/2, k;i <len-1;i++) {
        if(i < j)swap(y[i],y[j]);
//交换互为小标反转的元素，i<j保证交换一次
//i做正常的+1，j左反转类型的+1,始终保持i和j是反转的
        k = len/2;
        while(j >= k) {
            j -= k;
            k /= 2;
        }
        if(j < k)j += k;
    }
}
//做FFT
//len必须为2^k形式，
//on==1时是DFT，on==-1时是IDFT
void fft(Complex y[],int len,int on) {

    change(y,len);
    for(int h = 2; h <= len; h <<= 1) {
        Complex wn(cos(-on*2*PI/h),sin(-on*2*PI/h));
        for(int j = 0;j < len;j+=h) {
            Complex w(1,0);
            for(int k = j;k < j+h/2;k++) {
                Complex u = y[k];
                Complex t = w*y[k+h/2];
                y[k] = u+t;
                y[k+h/2] = u-t;
                w = w*wn;
            }
        }
    }
    if(on == -1) {
        for (int i = 0; i < len; i++)
            y[i].x /= len;
    }
}
int main() {

    while (scanf("%s%s", str1, str2)!=-1) {
        int len1 = strlen(str1);
        int len2 = strlen(str2);
        int len = 1;
        while (len < len1 * 2 || len < len2 * 2)len <<= 1;
        for (int i = 0; i < len1; i++)
            x1[i] = Complex(str1[len1 - 1 - i] - '0', 0);
        for (int i = len1; i < len; i++)
            x1[i] = Complex(0, 0);
        for (int i = 0; i < len2; i++)
            x2[i] = Complex(str2[len2 - 1 - i] - '0', 0);
        for (int i = len2; i < len; i++)
            x2[i] = Complex(0, 0);

        //求DFT
        fft(x1, len, 1);
        fft(x2, len, 1);
        for (int i = 0; i < len; i++) x1[i] = x1[i] * x2[i];
        fft(x1, len, -1);
        for (int i = 0; i < len; i++) sum[i] = (int) (x1[i].x + 0.5);
        for (int i = 0; i < len; i++) {
            sum[i + 1] += sum[i] / 10;
            sum[i] %= 10;
        }
        len = len1 + len2 - 1;
        while (sum[len] <= 0 && len > 0)len--;
        for (int i = len; i >= 0; i--) printf("%c", sum[i] + '0');
        puts("");
    }

    return 0;
}
```
