
* **前言**：不少数论题常见套路是：`打表 + 找规律`，找规律一般归结为数列问题。若能找出`a[n]`与前若干项的关系，则可以用 **矩阵快速幂** 以`O(logn)`的复杂度求解。若能找出 **通向公式**，则能用`O(1)`的复杂度求解。

## 一、
## 二、模板题
[来源：hdu #6185](http://acm.hdu.edu.cn/showproblem.php?pid=6185)
题目大意：求用1*2和2*1的格子去覆盖4*n的矩阵的方案数。
```c++
#include<bits/stdc++.h>

using namespace std;
typedef long long LL;

const int mod = int(1e9+7);
const LL ans[] = {1,5,11,36};        //前4项
const LL base[] = {0,1,0,0,0,0,1,0,0,0,0,1,-1,1,5,1}; //变换矩阵
//公式 a[i] = a[i-1] + 5 * a[i-2] + a[i-3] - a[i-4] 对应变换矩阵的最后一行-1,1,5,1
const int Size = 4;
LL n;

struct matrix{

    LL a[Size][Size];
    matrix(){           //默认为单位矩阵
        memset(a,0,sizeof(a));
        for(int i = 0; i < Size; i++) a[i][i] = 1;
    }
    matrix(const LL t[]){   //变换矩阵
        for(int i = 0, f = 0; i < Size; i++)
            for(int j = 0; j < Size; j++)
                a[i][j] = t[f++];
    }
    matrix operator*(matrix t){ //矩阵乘法
        matrix res;
        for(int i = 0; i < Size; i++)
            for(int j = 0;j < Size; j++){
                res.a[i][j] = 0;
                for(int k = 0; k < Size; k++)
                    res.a[i][j] = (res.a[i][j] + (a[i][k] * t.a[k][j]) % mod) % mod;
            }
        return res;
    }
};
matrix mod_pow(matrix x,LL n){      //矩阵快速幂

    matrix res;
    while(n){
        if(n & 1) res = res * x;
        n >>= 1;
        x = x * x;
    }
    return res;
}
void solve(){

    if(n <= Size){
        cout<<ans[n-1]<<endl;
        return;
    }
    LL res = 0;
    matrix tt = mod_pow(matrix(base),n - Size);
    for(int i = 0; i < Size; i++) (res += tt.a[Size-1][i] * ans[i] % mod) %= mod;
    cout<<(res + mod) % mod<<endl;
}
int main(){

    while(cin>>n) solve();

//    system("pause");
    return 0;
}
```