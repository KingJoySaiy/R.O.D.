## 1、二分查找数值
二分查找用于在某个递增区间内快速查询是否有某一个满足条件的值，若能找到，返回该值所在位置，复杂度为`O(log(n))`。具体实现如下：

```c++
    //离散整型数值的查找
    int l = -1, r = n, m;
    while(l < r){
        m = (l + r) >> 1;
        if(a[m] < x) l = m + 1;
        else if(a[m] > x) r = m - 1;
        else break;
    }
    cout<<m<<endl;
```

* 查找题过于简单，不建议手撸。建议直接使用`find()、lower_bound()、upper_bound()`。

## 2、离散型二分搜索索引
二分搜索多用于在某一数组内快速搜索出是否有有满足题意的数值所在的索引，复杂度为`O(log(n))`。假设已经给定起判断作用的方法check(x)，则具体实现有以下4种情况：

1. 左半部分区间都满足，找出最右边的满足条件的值，用符号表示即为"≤";

```c++
//    int l=-1,r=n;     2'
    int l = 0, r = n;  
//    while(r-l>1){     2'
    while(r > l){    
        int m = (l + r) >> 1;
        if(check(m)) r = m;
        else l = m + 1;
    }
    int res = r;
```

2. 左半部分都满足，找出从左往右第一个不满足条件的值，即"<";

```c++
    int l = 0, r = n;
    while(r > l){
        int m = (l + r) >> 1;
        if(check(m)) r = m + 1;
        else l = m + 1;
    }
    int res = r;
```

3. 右半部分区间都满足，找出最左边的满足条件的值，用符号表示即为"≥";实现同1;

4. 右半部分都满足，找出从右往左第一个不满足条件的值，即">";

```c++
    int l = 0, r = n;
    while(r > l){
        int m = (l + r) >> 1;
        if(check(m)) r = m - 1;
        else l = m;
    }
    int res = l;
```

## 三、连续型二分搜索区间
1. 区间为连续的浮点数时，一直二分直到m与上一次的m近似相等时终止，或者直接二分100次即可。由于是要搜索出某一确切的边界点，所以"≤"和"≥"实现一样;

```c++
    const double eps = 1e-8;
    double l = 0, r = n, m = (l+r)/2, pre = -1;
    while(abs(m - pre) > eps){
        m = (l + r) / 2;
        if(check(m)) r = m;
        else l = m;
        pre = m;
    }
    double res = m;
```
```c++
    double l = 0,r = n, m;
    int ct = 100;
    while(ct--){
        m = (l + r) / 2;
        if(check(m)) r = m;
        else l = m;
    }
    double res = m;
```

2. 需要写出`check()`方法时才需手撸二分，一般情况下`lower_bound()`和`upper_bound()`就能解决大部分简单二分题了。




