## 一、单源最短路
### 1. Bellman-Ford
* 边的权值有负数时，可用 **Bellman-Ford算法** 求单源最短路，并判断有无负权回路。
```c++
const int maxn = 1005;
const int inf = (INT_MAX>>1) - 10;
int cost[maxn][maxn], d[maxn], n;

struct node{

    int from, to, cost;
    node(int x, int y, int z):from(x), to(y), cost(z){}
};
vector<node> edge;

bool Bellman_ford(int x){    //若有负环则返回true

    fill(d, d + maxn, inf);
    d[x] = 0;
    int ct = n;
    while(--ct){
        bool flag = false;
        for(int i = 0; i < edge.size(); i++){
            if(d[edge[i].to] > d[edge[i].from] + edge[i].cost){
                flag = true;
                d[edge[i].to] = d[edge[i].from] + edge[i].cost;
            }
        }
        if(!flag) return false; //无法继续更新d，则无负环
    }
    for(int i = 0; i < edge.size(); i++)
        if(d[edge[i].to] > d[edge[i].from] + edge[i].cost) return true;
    return false;
}
```

### 2. Dijstra
* 求单源无负权的最短路时， **Dijstra算法** 的时效性较好，时间复杂度为`O(V ^ 2 + E)`。
```c++
const int inf = (INT_MAX >> 1) - 10;
const int maxn = 1005;
int cost[maxn][maxn], d[maxn], n;
bool book[maxn];

void ini(){

    for(int i = 0; i < maxn; i++){
        fill(cost[i], cost[i] + maxn, inf);
        cost[i][i] = 0;
    }
}
void Dijstra(int x){

    memset(book, 0, sizeof(book));
    for(int i = 1;i <= n; i++) d[i] = cost[x][i];
    book[x]=true;

    for(int i = 1, tmp; i < n; i++){
        tmp = inf;
        for(int j = 1; j <= n; j++)
            if(!book[j] and d[j] < tmp){
                tmp = d[j];
                x = j;
            }
        book[x] = true;
        for(int j = 1; j <= n; j++)
            d[j] = min(d[j], d[x] + cost[x][j]);
    }
}
```

* 第二种实现方式如下
```c++
typedef pair<int, int> pp;
const int inf = (INT_MAX >> 1) - 10;
const int maxn = int(1e4 + 5);

struct data{

    int to, dis;
    data(int x = 0, int y = 0): to(x), dis(y){}
};
vector<data> a[maxn];
int d[maxn];

void dijstra(int x) {

    priority_queue<pp, vector<pp>, greater<pp> > que;   //first->dist, second->to
    fill(d, d + maxn, inf);
    d[x] = 0;
    que.push(make_pair(0, x));
    
    int from;
    pp t;
    data s;
    while(!que.empty()) {
        t = que.top(); que.pop();
        from = t.second;
        if(d[from] < t.first) continue;
        for(int i = 0; i < a[from].size(); i++) {
            s = a[from][i];
            if(d[s.to] > d[from] + s.dis) {
                d[s.to] = d[from] + s.dis;
                que.push(make_pair(d[s.to], s.to));
            }
        }
    }
}
```

## 二、任意两点的最短路
* 求多源无负权边的最短路时，使用 **Floyd-Warshall算法** 处理有向图或负权的最短路径问题，时效性较差，时间复杂度O(V^3)。
```c++
const int maxn = 1005;
const int inf = (INT_MAX >> 1) - 5;
int cost[maxn][maxn], n;

void ini(){

    for(int i = 0; i < maxn; i++){
        fill(cost, cost + maxn, inf);
        cost[i][i] = 0;
    }
}
void Floyd_Warshall(){
    
    for(int k = 1; k <= n; k++)
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= n; j++)
                cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);
}
```

## 三、次短路
[来源：HRBUST #1050](http://acm.hrbust.edu.cn/index.php?m=ProblemSet&a=showProblem&problem_id=1050)
* **题目大意** : 在无重边无自环的 **带权有向图** 中，求从节点1到节点m的次短路。

```c++
#include <bits/stdc++.h>

using namespace std;
typedef pair<int, int> pp;  //first -> id, second -> cost

const int maxn = 1005;
const int inf = INT_MAX / 2 - 10;

struct data {

    int id, c, flag;
    data(int id = 0, int c = 0, int flag = 0) : id(id), c(c), flag(flag) {}
    bool operator < (const data &t) const {
        return c > t.c;
    }
};
vector<pp> a[maxn];
bool book[maxn][2];
int dist[maxn][2], n, m, x, cost;

void Dijkstra(int n, int s) {

    memset(book, false, sizeof(book));
    for (int i = 1; i <= n; i++) dist[i][0] = dist[i][1] = inf;
    priority_queue<data> que;
    dist[s][0] = 0;
    que.push(data(s, 0, 0));
    while (!que.empty()) {
        data tmp = que.top(); que.pop();
        int u = tmp.id, flag = tmp.flag;
        if (book[u][flag]) continue;
        book[u][flag] = true;
        for (int i = 0; i < a[u].size(); i++) {
            int id = a[u][i].first, cost = a[u][i].second;
            if (!book[id][0] and dist[id][0] > dist[u][flag] + cost) {
                dist[id][1] = dist[id][0];
                dist[id][0] = dist[u][flag] + cost;
                que.push(data(id, dist[id][0], 0));
                que.push(data(id, dist[id][1], 1));
            } else if (!book[id][1] and dist[id][1] > dist[u][flag] + cost) {
                dist[id][1] = dist[u][flag] + cost;
                que.push(data(id, dist[id][1], 1));
            }
        }
    }
}
int main() {

    ios::sync_with_stdio(false), cin.tie(), cout.tie();
    while (cin >> n) {
        for (int i = 0; i <= n; i++) a[i].clear();
        for (int i = 1; i <= n; i++) {
            cin >> m;
            while (m--) {
                cin >> x >> cost;
                a[i].emplace_back(x, cost);
            }
        }
        Dijkstra(n, 1);
        cout << dist[n][1] << endl;
    }

    return 0;
}   
```

## 四、第k短路
[来源：poj #2449](http://poj.org/problem?id=2449)
* **题目大意** : 在无重边无自环的 **带权有向图** 中，求从节点s到节点e的第k短路，若不存在则-1。

```c++
#include <iostream>
#include <algorithm>
#include <cstring>
#include <climits>
#include <queue>
#include <vector>

using namespace std;
typedef pair<int, int> pp;      //first -> id, second -> cost

const int maxn = 1005;
const int inf = INT_MAX / 2 - 5;

vector<pp> a[maxn], reva[maxn];
int n, m, x, y, cost;
int dist[maxn], s, e, k;
bool book[maxn];

struct data {

    int v, c;
    data(int v = 0, int c = 0) : v(v), c(c) {}
    bool operator < (const data &t) const {
        return c + dist[v] > t.c + dist[t.v];
    }
};

void Dijkstra(int n, int s) {
    
    memset(book, 0, sizeof(book));
    for (int i = 1; i <= n; i++) dist[i] = inf;
    priority_queue<data> que;
    dist[s] = 0;
    que.push(data(s, 0));
    while (!que.empty()) {
        data tep = que.top(); que.pop();
        int u = tep.v;
        if (book[u]) continue;
        book[u] = true;
        for (int i = 0; i < a[u].size(); i++) {
            int v = a[u][i].first, cost = a[u][i].second;
            if (!book[v] and dist[v] > dist[u] + cost) {
                dist[v] = dist[u] + cost;
                que.push(data(v, dist[v]));
            }
        }
    }
}
int astar(int s) {

    priority_queue<data> que;
    que.push(data(s, 0));
    k--;
    while (!que.empty()) {
        data pre = que.top(); que.pop();
        int u = pre.v;
        if (u == e) {
            if (k) k--;
            else return pre.c;
        }
        for (int i = 0; i < reva[u].size(); i++) {
            int v = reva[u][i].first, c = reva[u][i].second;
            que.push(data(v, pre.c + c));
        }
    }
    return -1;
}
int main() {

    ios::sync_with_stdio(false), cin.tie(), cout.tie();
    while (cin >> n >> m) {
        for (int i = 0; i <= n; i++) {
            a[i].clear();
            reva[i].clear();
        }
        while (m--) {
            cin >> x >> y >> cost;
            reva[x].push_back(pp(y, cost));
            a[y].push_back(pp(x, cost));
        }
        cin >> s >> e >> k;
        Dijkstra(n, e);
        if (dist[s] == inf) {
            cout << -1 << endl;
            continue;
        }
        if (s == e) k++;
        cout << astar(s) << endl;
    }

    return 0;
}
```
