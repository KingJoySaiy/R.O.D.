# [反转问题]
## 一、题目描述
* 来源: POJ 3279 (Fliptile)
* 给定m*n的矩阵，1为黑色，0为白色。可选定某个格子翻转，其本身及上下左右共5个各自都将变色，目的是让所有格子都为白色。求如何操作，使得翻转数最小？
* 条件: 1<=m,n<=15，2000ms
## 二、基本思路
易知同一格子翻转偶数次会恢复原状，所以对于每个格子，翻转数只能是0或1。且翻转的次序与最终形态无关，所以可以按次序暴力。
尝试从上往下，从左往右暴力。由于翻转范围为连通的“十”字型，所以务必枚举出第一行的所有翻转方法**(共2^n种方法，显然用二进制法)**，然后从第二行开始，判定(x,y)是否需要翻转，只需检查(x-1,y)是否为白色，因为此时(x-1,y)只能被(x,y)翻转。
待暴力结束后，还需判别最后一行是否全为白。因为此时除最后一行其他所有格子皆为白色，最后一行一旦继续翻转，必然导致倒数第二行变为黑色，所以最后一行不能翻转。一旦有黑色格子，则此样例无解。
## 三、具体实现
```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=20;
const int dx[]={0,-1,0,0,1};
const int dy[]={-1,0,0,1,0};
int m,n,a[maxn][maxn];
bool tmp[maxn][maxn];   //tmp即时保存最优解
bool b[maxn][maxn];     //b标记颜色

bool check(int x,int y){  //判定(x,y)是否需要翻转

    int c=a[x][y];
    for(int i=0;i<5;i++){
        int tx=x+dx[i],ty=y+dy[i];
        if(tx>=0&&ty>=0&&tx<m&&ty<n) c+=b[tx][ty];
    }
    return c&1;
}
int calc(){             //已知第1行，求最小操作数

    for(int i=1;i<m;i++)
        for(int j=0;j<n;j++)
            if(check(i-1,j)) b[i][j]=true;

    for(int j=0;j<n;j++)    //如果最后一行不全为白，则无解
        if(check(m-1,j)) return -1;

    int ct=0;
    for(int i=0;i<m;i++)
        for(int j=0;j<n;j++)
            ct+=b[i][j];
            
    return ct;
}
int main() {

    cin>>m>>n;
    for(int i=0;i<m;i++)
        for(int j=0;j<n;j++)
            cin>>a[i][j];

    int res=INT_MAX;
    for(int i=0;i<(1<<n);i++){
        memset(b,0,sizeof(b));
        for(int j=0;j<n;j++)
            b[0][j]=(i>>j)&1;   //二进制法枚举第1行的所有情况

        int t=calc();
        if(t!=-1&&res>t){
            res=t;
            memcpy(tmp,b,sizeof(b));
        }
    }

    if(res==INT_MAX) cout<<"IMPOSSIBLE"<<endl;
    else{
        for(int i=0;i<m;i++)
            for(int j=0;j<n;j++)
                printf("%d%c",tmp[i][j],j==n-1?'\n':' ');
    }

return 0;
}
```


