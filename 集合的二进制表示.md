# 集合的二进制表示
在程序中表示集合的方法有很多种，当元素比较少时，可以用二进制的形式来表示，注意这里的集合没有重复元素。
## 一、集合的存储
方法是用一串二进制的数存，第i位表示i这个数是否在集合中。设集合S的最大的数小于n，则S可以表示成集合{0,1,...,n-1}的子集，所以可以用如下方式编码成整数。

<img src="http://www.sciweavers.org/tex2img.php?eq=%24%24%20%5Cbegin%20%7Bequation%7D%20f%28S%29%3D%5Csum_%7Bi%5Cin%20S%7D%202%5Ei%20%5Cend%7Bequation%7D%20%24%24&bc=White&fc=Black&im=jpg&fs=12&ff=arev&edit=0" align="center" border="0" alt="$$ \begin {equation} f(S)=\sum_{i\in S} 2^i \end{equation} $$" width="136" height="24" />


## 二、集合的运算
1. 空集:`0`
2. 只含有第i个元素的集合{i}:`1<<i`
3. 含有全部n个元素的集合{0,1,...,n-1}:`(1<<n)-1`
4. 判断第i个元素是否属于集合S:`if(S>>i&1)`
5. 向集合中加入第i个元素SU{i}:`S|1<<i`
6. 向集合中去除第i个元素S\{i}:`S&~(1<<i)`
7. 集合S和T的并集:`S|T`
8. 集合S和T的交集:`S&T`
9. 集合S和T的对称差:`S^T`
## 三、子集的输出
### 1、元素的输出
从1到n枚举，如果在S中就输出
```c++
for(int i=0;i<n;i++){
        if(s&(1<<i)) printf("%d ",i);
        putchar('\n');
    }
```
### 2、枚举S的所有子集
已知S是一个二进制码，其本身也是某个集合的子集，因而可以从S开始每次减1直到0为止。由于T-1并不一定是S的子集，所以要将T-1和S按位取与&。**(T-1)&S会忽略S中的0而从T中减去1。**
```c++
    int T=S;
    do{
        //对子集的处理
        T=(T-1)&S;
    }while(T!=S);//处理完0后，-1&S==S
```

### 3、枚举大小为k的子集的方法
按字典序枚举{0,1,...,n-1}所包含的所有大小为k的子集，易知最小子集是(1<<k)-1，所以用它作为初始值，继而依次求出S之后的二进制码。例如0101110之后是0110011，0111110之后是1001111。方法如下:
1. **求出最低位的1开始的连续为1的区间**(0101110->0001110)
2. **将这一区间全部变为0，并将区间左侧的那个0变为1**(0101110->0110000)
3. **将第1步里取出的区间右移，直到剩下的1的个数减少了1个**(0001110->0000011)
4. **将第2步和第3步的结果按位取或**(0110000|0000011=0110011)

设x为最低位的1独立出来后的值，则`x=S&((~S)+1)`或`x=S&(-S)`。为将S最低位开始的连续1都置为0，设`y=S+x`。则`S&~y`即为取得最低位1开始的连续为1的区间。

**比如:`S=0101110`,则`x=00000101`,`y=0110000`,`S&~y=0001110`**

同时，y也是第2步所求的值，z/x即可将z不断右移直到最低位为1。从而z/x右移一位就可得到第3步所求的值了。所以S之后的二进制码表示为`S=((S&-y)/x>>1)|y`。

```c++
    int k=3,n=9;
    int S=(1<<k)-1;
    while(S<(1<<n)){
        //这里进行针对组合的处理
        int x=S&-S,y=S+x;
        S=((S&~y)/x>>1)|y;
    }
```



