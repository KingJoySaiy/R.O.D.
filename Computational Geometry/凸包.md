## 一、凸包问题
在二维欧几里得空间中给定一个多边形，若对于其边界上或内部的任意两个点，连接这两个点的线段上的所有点都被包含于该多边形的边界上或内部，则该多边形为凸多边形。
凸包问题可以简单描述为：在平面直角坐标系中给定若干个点，求出以某些点为端点的凸多边形，使其边界或内部能包含所有给定的点。
## 二、Graham扫描法
解决凸包问题最常用的方法是Graham扫描法，基本思想如下：
1. 易知纵坐标最小的点p0必为凸包上的点（纵坐标最小的点有多个，取横坐标最小的点），把该点作为序列的第一个元素。
2. 计算其他点相对于p0的幅角α ，安从小到大的顺序对各个点排序（α 相同的点有多个时，α 小的点在前），从而得到序列`p0,p1,p2...p(n-1)`。
3. 把p0和p1入栈，设`pre = p0 , now = p1 , nex = p2`，分别记录前点、当前点、后点，若向量`now->nex`和向量`pre->now`成左转关系，则nex入栈，开始判断下一个点。若不成左转关系，则把now不断出栈，知道出现左转关系为止，把nex入栈。
4. 待遍历完后，从栈底到栈顶就是安逆时针存储的凸包的所有端点。
## 三、模版题（凸包）
<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1392">来源：hdu #1392</a><br>
题目大意：给定n个点坐标，求出凸包的周长。
```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn=105;
const double eps=1e-8;

class point{
public:
    double x,y;
    point(){}
    point(double a,double b):x(a),y(b){}
    point operator-(point t){   //向量减法
        return point(x-t.x,y-t.y);
    }
    double operator*(point t){  //向量叉积
        return x*t.y-y*t.x;
    }
    bool operator<(const point t)const{
        if(fabs(y-t.y)<eps) return x<t.x;
        return y<t.y;
    }
    double len(){   //向量的模
        return sqrt(x*x+y*y);
    }
}a[maxn],s[maxn];//a为初始序列,s为栈

double cb(point a,point b,point o){ //向量oa,ob叉积

    return (a-o)*(b-o);
}
void Graham(int &n){

    int top=1,tt;
    s[0]=a[0];
    s[1]=a[1];
    for(int i=2;i<n;i++){   //从前往后扫
        while(top>0&&cb(a[i],s[top],s[top-1])>=0) top--;
        s[++top]=a[i];
    }
    tt=top;
    s[++top]=a[n-2];
    for(int i=n-3;i>=0;i--){    //从后往前扫
        while(top>tt&&cb(a[i],s[top],s[top-1])>=0) top--;
        s[++top]=a[i];
    }
    n=top;
}

int main(){

    int n;
    while(scanf("%d",&n)!=EOF&&n){
        for(int i=0;i<n;i++) scanf("%lf%lf",&a[i].x,&a[i].y);
        sort(a,a+n);

        int ct=0;
        for(int i=1;i<n;i++)    //去除重复的点
            if(fabs(a[i].x-a[ct].x)>eps||fabs(a[i].y-a[ct].y>eps)) a[++ct]=a[i];
        ct++;

        if(ct==1){
            puts("0.00");
            continue;
        }
        if(ct==2){
            printf("%.2lf\n",(a[0]-a[1]).len());
            continue;
        }

        Graham(ct);
        double res=(s[0]-s[ct-1]).len();
        for(int i=1;i<ct;i++) res+=(s[i]-s[i-1]).len();
        printf("%.2lf\n",res);
    }

    return 0;
}

```