## 一、凸包问题
在二维欧几里得空间中给定一个多边形，若对于其边界上或内部的任意两个点，连接这两个点的线段上的所有点都被包含于该多边形的边界上或内部，则该多边形为凸多边形。
凸包问题可以简单描述为：在平面直角坐标系中给定若干个点，求出以某些点为端点的凸多边形，使其边界或内部能包含所有给定的点。
## 二、Graham扫描法
解决凸包问题最常用的方法是Graham扫描法，基本思想如下：
1. 易知横坐标最小的点p0必为凸包上的点（横坐标最小的点有多个，取纵坐标最小的点），把该点作为序列的第一个元素。
2. 计算其他点相对于p0的幅角α ，安从小到大的顺序对各个点排序（α 相同的点有多个时，α 小的点在前），从而得到序列`p0,p1,p2...p(n-1)`。易知p0和p(n-1)必为凸包上的顶点，所以应当分成上下两条链来求解，求下链时从小到大正序扫描，求上链时从大到小倒序扫描。
3. 把p0和p1入栈，设`pre = p0 , now = p1 , nex = p2`，分别记录前点、当前点、后点，若向量`now->nex`和向量`pre->now`成左转关系，则nex入栈，开始判断下一个点。若不成左转关系，则把now不断出栈，知道出现左转关系为止，把nex入栈。
4. 待遍历完后，从栈底到栈顶就是安逆时针存储的凸包的所有端点。排序复杂度为O(nlogn)，剩余部分为O(n)。

## 三、旋转卡壳
## 四、模版题（凸包）
<a href="http://poj.org/problem?id=2187">来源：poj #2187</a><br>
题目大意：
```c++
#include <cstdio>
#include <cstdlib>
#include <algorithm>
using namespace std;
int s[50005],top,n;

class point{
public:
    int x,y;
    point (int xx=0,int yy=0):x(xx),y(yy){}
    point operator -(point b){
        return point(x-b.x,y-b.y);
    }
    int operator *(point b){
        return (x*b.y-y*b.x);
    }
    int len(){
        return x*x+y*y;
    }
}a[50005];

int cmp(const void *xx,const void *yy){ //逆时针排序 返回正数要交换
    struct point *c=(struct point *)xx;
    struct point *d=(struct point *)yy;
    int k=(*c-a[0])*(*d-a[0]);
    if(k<0) return 1;
    else if(k==0 && ((*c-a[0]).len()-(*d-a[0]).len())>=0)
        return 1;
    else return -1;
}
void graham(int n){    //Graham生成凸包

    s[0]=0;
    s[1]=1;
    top=1;
    for(int i=2;i<n;i++){
        while(top>0 && (a[s[top]]-a[s[top-1]])*(a[i]-a[s[top-1]])<=0)
            top--;
        s[++top]=i;
    }
    int tmp=top;
    for(int i=n-2;i>=0;i--){
        while(top>tmp && (a[s[top]]-a[s[top-1]])*(a[i]-a[s[top-1]])<=0)
            top--;
        s[++top]=i;
    }
}

int qiake(){  //旋转卡壳

    int q=1,ans=0;
    s[top]=0;
    for(int i=0;i<top;i++) {
        while( (a[s[i+1]]-a[s[i]])*(a[s[q+1]]-a[s[i]]) >
               (a[s[i+1]]-a[s[i]])*(a[s[q]]-a[s[i]]) )
            q=(q+1)%(top);
        ans=max(ans,max((a[s[i]]-a[s[q]]).len(),(a[s[i+1]]-a[s[q+1]]).len()));
    }
    return ans;
}

int main(){

    while(~scanf("%d",&n)){
        for(int i=0;i<n;i++)
            scanf("%d%d",&a[i].x,&a[i].y);

        int u=0;
        for(int i=1;i<n;i++) //找左下角的点
            if(a[i].y<a[u].y||(a[i].y==a[u].y&&a[i].x<a[u].x)) u=i;
        swap(a[0],a[u]);

        qsort(a+1,n-1,sizeof(a[0]),cmp);
        graham(n);

        printf("%d\n",qiake());
    }

    return 0;
}

```