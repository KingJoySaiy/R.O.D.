```c++
#ifndef BASIC_FUNCTION_HEAD_H   //head.h
#define BASIC_FUNCTION_HEAD_H

#include <iostream>
#include <cstring>
#include <cmath>

using namespace std;

#define Vector Point   //向量和点的都用xy表示，但要区分

const double eps = 1e-8;
const double PI = acos(-1);
const double inf = 1e12;

int dcmp(double x) {     //判断x是否为0

    if (fabs(x) < eps) return 0;
    return x < 0 ? -1 : 1;
}
struct Point {           //定义点(向量)

    double x, y;
    Point(double x = 0, double y = 0) : x(x), y(y) {}
    Vector operator + (const Vector &b) const {       //向量+向量
        return Vector(x + b.x, y + b.y);
    }
    Vector operator - (const Point &b) const {        //向量-向量 or 点-点
        return Vector(x - b.x, y - b.y);
    }
    double operator ^ (const Vector &b) const {       //向量的叉积
        return x * b.y - y * b.x;
    }
    double operator * (const Vector &b) const {       //向量的点积
        return x * b.x + y * b.y;
    }
    Vector operator * (const double t) const {        //向量乘浮点数
        return Vector(t * x, t * y);
    }
    bool operator == (const Point &b) const {         //判断两点坐标相等
        return !dcmp(x - b.x) and !dcmp(y - b.y);
    }
    bool operator < (const Point &b) const {          //按x升序，x相等则按y升序
        return dcmp(x - b.x) ? (x < b.x) : (dcmp(y - b.y) < 0);
    }
    double len() {       //返回向量的长度
        return hypot(x, y); //cmath库函数，由2直角边长求斜边长
    }
    double distance(Point &t) {  //返回2点之间距离
        return hypot(x - t.x, y - t.y);
    }
    double angle(Vector &b) {           //两向量的夹角
        return acos((*this * b) / len() / b.len());
    }
    double rad(Point &a, Point &b) {    //计算向量pa与向量pb的夹角
        Point &p = *this;
        return fabs(atan2(fabs((a - p) ^ (b - p)), (a - p) * (b - p)));
    }
    Point changeLen(double r) {       //转换为长度为r的向量
        double l = len();
        if (!dcmp(l)) return *this;
        r /= l;
        return Vector(x * r, y * r);
    }
    void rotate0(double ang) {           //绕原点逆时针旋转ang弧度
        double tx = x, ty = y;
        x = tx * cos(ang) - ty * sin(ang);
        y = tx * sin(ang) + ty * cos(ang);
    }
    Point rotate(Point p, double ang) { //绕点p逆时针旋转ang弧度
        Point v = (*this) - p;
        double c = cos(ang), s = sin(ang);
        return Point(p.x + v.x * c - v.y * s, p.y + v.x * s + v.y * c);
    }
    Vector normal() {                    //返回向量的单位法线（左旋90度,长度归一）
        double l = len();
        return Vector(-y / l, x / l);
    }
};

struct Line {

    Point s, e;
    Line() {}
    Line(Point s, Point e) : s(s), e(e) {}
    Line(Point p, double ang) {         //根据点和倾斜角确定一条直线
        s = p;
        if (!dcmp(ang - PI / 2)) e = s + Vector(0, 1);
        else e = s + Point(1, tan(ang));
    }
    Line(double a, double b, double c) {    //根据直线的一般方程ax + by + c = 0求直线
        if(!dcmp(a)) {
            s = Point(0, -c / b);
            e = Point(1, -c / b);
        } else if (!dcmp(b)) {
            s = Point(-c / a, 0);
            e = Point(-c / a, 1);
        } else {
            s = Point(0, -c / b);
            e = Point(1, (-c - a) / b);
        }
    }
    bool operator == (Line &t) {        //判断2线段是否相等
        return s == t.s and e == t.e;
    }
    double len() {                      //返回线段长度
        return s.distance(e);
    }
    double angle() {                    //返回倾斜角
        double k = atan2(e.y - s.y, e.x - s.x);
        if (dcmp(k) < 0) k += PI;
        if (dcmp(k - PI) == 0) k -= PI;
        return k;
    }
    bool onLine(Point p) {              //判断点是否在直线上
        return !dcmp((p - s) ^ (p - e));
    }
    bool onSegment(Point p) {           //判断点是否在线段上
        return !dcmp((p - s) ^ (p - e)) and dcmp((p - s) * (p - e)) <= 0;
    }
    bool parallel(Line t) {             //判断2线段是否平行
        return !dcmp((e - s) ^ (t.e - t.s));
    }
    pair<int, Point> operator & (const Line &b) const {   //两直线相交求交点

        //第一个值为0表示直线重合，为0表示重合，为1表示平行，为2是相交
        Point res = s;
        if (dcmp((s - e) ^ (b.s - b.e)) == 0) {
            if (dcmp((s - b.e) ^ (b.s - b.e)) == 0) return make_pair(0, res);    //重合
            else return make_pair(1, res);              //平行
        }
        double t = ((s - b.s) ^ (b.s - b.e)) / ((s - e) ^ (b.s - b.e)); //用到定比分点
        res.x += (e.x - s.x) * t;
        res.y += (e.y - s.y) * t;
        return make_pair(2, res);                        //只有第一个值为2时，交点才有意义
    }
    int interseg(Line v) {        //判断线段相交（2规范相交，1不规范相交，0不相交）
        int d1 = dcmp((e - s) ^ (v.s - s));
        int d2 = dcmp((e - s) ^ (v.e - s));
        int d3 = dcmp((v.e - v.s) ^ (s - v.s));
        int d4 = dcmp((v.e - v.s) ^ (e - v.s));
        if ((d1 ^ d2) == -2 and (d3 ^ d4) == -2) return 2;
        return (!d1 and dcmp((v.s - s) * (v.s - e)) <= 0) or
         (!d2 and dcmp((v.e - s) * (v.e - e)) <= 0) or
         (!d3 and dcmp((s - v.s) * (s - v.e)) <= 0) or
         (!d4 and dcmp((e - v.s) * (e - v.e)) <= 0);
    }
};

#endif //BASIC_FUNCTION_HEAD_H
```

这是分割线
- - - - 

```c++
#include "head.h"       //main.cpp

double dist(Point a, Point b) {         //两点间距离

    return sqrt((a - b) * (a - b));
}

bool interSeg(Line l1, Line l2) {           //判断线段相交（允许在端点处相交）
    return
            max(l1.s.x, l1.e.x) >= min(l2.s.x, l2.e.x) and
            max(l2.s.x, l2.e.x) >= min(l1.s.x, l1.e.x) and
            max(l1.s.y, l1.e.y) >= min(l2.s.y, l2.e.y) and
            max(l2.s.y, l2.e.y) >= min(l1.s.y, l1.e.y) and
            dcmp((l2.s - l1.e) ^ (l1.s - l1.e)) * dcmp((l2.e - l1.e) ^ (l1.s - l1.e)) <= 0 and
            dcmp((l1.s - l2.e) ^ (l2.s - l2.e)) * dcmp((l1.e - l2.e) ^ (l2.s - l2.e)) <= 0;
}
bool interSeg2(Line l1, Line l2) {          //判断线段相交（任一线段的两端点都在另一条线段的两侧）

    double c1 = (l1.e - l1.s) ^(l2.s - l1.s), c2 = (l1.e - l1.s) ^(l2.e - l1.s);
    double c3 = (l2.e - l2.s) ^(l1.s - l2.s), c4 = (l2.e - l2.s) ^(l1.e - l2.s);
    return dcmp(c1) * dcmp(c2) < 0 and dcmp(c3) * dcmp(c4) < 0;
}

int line_inter_seg(Line l1, Line l2) {      //判断直线l1与线段l2相交（2规范相交，1不规范相交，0不相交）

    int d1 = dcmp((l1.e - l1.s) ^ (l2.s - l1.s));
    int d2 = dcmp((l1.e - l1.s) ^ (l2.e - l1.s));
    if ((d1 ^ d2) == -2) return 2;
    return !d1 or !d2;
}

double dis_point_line(Point p, Line l) { //点到直线的最短距离

    Vector v1 = l.e - l.s, v2 = p - l.s;
    return fabs((v1 ^ v2) / v1.len());
}

Point point_line(Point P, Line L) {     //点到直线最近的点

    Point v = L.e - L.s;
    return L.s + v * (((P - L.s) * v) / (v * v));
}

double dis_point_lineseg(Point P, Line L) {  //点到线段的最近距离

    if (L.s == L.e) return (P - L.s).len();
    Vector v1 = L.e - L.s, v2 = P - L.s, v3 = P - L.e;
    if (dcmp(v1 * v2) < 0) return v2.len();
    if (dcmp(v1 * v3) > 0) return v3.len();
    return fabs(v2 ^ v2) / v1.len();
}

Point point_lineSeg(Point P, Line L) {      //点到线段的最近点

    Point result;
    double t = ((P - L.s) * (L.e - L.s)) / ((L.e - L.s) * (L.e - L.s));
    if (t >= 0 and t <= 1) {
        result.x = L.s.x + (L.e.x - L.s.x) * t;
        result.y = L.s.y + (L.e.y - L.s.y) * t;
    } else {
        if (dist(P, L.s) < dist(P, L.e)) result = L.s;
        else result = L.e;
    }
    return result;
}

double calc_area(Point p[], int n) {              //点的编号从0~n-1，计算多边形面积

    double res = 0;
    for (int i = 1; i < n - 1; i++) res += (p[i] - p[0]) ^ (p[i + 1] - p[0]);
    return res / 2;
}

int in_convex_poly(Point a, Point p[], int n) {     //判断点在凸多边形内

    //-1:点在凸多边形外，0:点在凸多边形边界上，1:点在凸多边形内
    for (int i = 0; i < n; i++) {
        if (dcmp((p[i] - a) ^ (p[(i + 1) % n] - a)) < 0) return -1;
        else if (Line(p[i], p[(i + 1) % n]).onSegment(a)) return 0;
    }
    return 1;
}

int inPoly(Point p, Point poly[], int n) {      //射线法判断点在任意多边形内，顶点数≥3

    //-1:点在凸多边形外，0:点在凸多边形边界上，1:点在凸多边形内
    int cnt = 0;
    Line ray, side;
    ray.s = p;
    ray.e.y = p.y;
    ray.e.x = -inf;         //-INF,注意取值防止越界
    for (int i = 0; i < n; i++) {
        side.s = poly[i];
        side.e = poly[(i + 1) % n];
        if (side.onSegment(p)) return 0;            //如果平行轴则不考虑
        if (!dcmp(side.s.y - side.e.y)) continue;
        if (ray.onSegment(side.s)) {
            if (dcmp(side.s.y - side.e.y) > 0) cnt++;
        } else if (ray.onSegment(side.e)) {
            if (dcmp(side.e.y - side.s.y) > 0) cnt++;
        } else if (interSeg(ray, side)) cnt++;
    }
    if (cnt % 2 == 1) return 1;
    return -1;
}

bool isconvex(Point *poly, int n) {             //判断凸多边形

    bool s[3];
    memset(s, false, sizeof(s));
    for (int i = 0; i < n; i++) {
        s[dcmp((poly[(i + 1) % n] - poly[i]) ^ (poly[(i + 2) % n] - poly[i])) + 1] = true;
        if (s[0] and s[2]) return false;
    }
    return true;
}

int main() {


    return 0;
}
```
